<canvas id="canvas" width="300" height="300"></canvas>
<script src="../web-lib/processing.js"></script>
<script src="../web-lib/functional-light.js"></script>
<script>
//Vamos a usar http://processingjs.org/
// o https://p5js.org/reference/

// Importamos las librerias
let { append, cons, first, isEmpty, isList, length, rest } = functionalLight;

function make(data, attribute) {
	return Object.assign({}, data, attribute);
}

/**
 * Ejemplo de pintar un rectángulo coloreado en un canvas cuadrado
 * No requiere interacción con el usuario
 */

function sketchProc(processing) {
	/**
	 * Esto se llama antes de iniciar el juego
	 */
	processing.setup = function() {
		processing.frameRate(10);
		processing.size(400, 400);
		processing.state = {
			world1: { x: 50, y: 200, ancho: 100, alto: 100 },
			world2: { x1: 50, y1: 200, x2: 100, y2: 150, x3: 100, y3: 250 },
			world3: { x: 270, y: 200, ancho: 30, alto: 30 }
		};
	};

	// Dibuja algo en el canvas. Aqui se pone todo lo que quieras pintar
	processing.drawGame = function(world) {
		const w1 = world.world1;
		const w2 = world.world2;
		const w3 = world.world3;
		processing.noStroke();
		processing.background(240, 240, 240);
		processing.fill(255, 204, 0);
		processing.ellipse(w1.x, w1.y, w1.ancho, w1.alto);
		processing.fill(255, 191, 128);
		processing.ellipse(w3.x, w3.y, w3.ancho, w3.alto);
		processing.fill(240, 240, 240);
		processing.triangle(w2.x1, w2.y1, w2.x2, w2.y2, w2.x3, w2.y3);
	};

	//Actualiza el mundo despues de cada frame. En este ejemplo, no cambia nada, solo retorna una copia del mundo

	processing.onTic = function(world) {
		const w1 = world.world1;
		const w2 = world.world2;
		const w3 = world.world3;
		if (w3.x == w1.x + 30) {
			return {
				world1: { x: w1.x + 10, y: w1.y, ancho: w1.ancho, alto: w1.alto },
				world2: {
					x1: w1.x,
					y1: w1.y,
					x2: w2.x2 + 10,
					y2: w2.y2 + 25,
					x3: w2.x3 + 10,
					y3: w2.y3 - 25
				},
				world3: { x: w3.x, y: w3.y, ancho: 0, alto: 0 }
			};
		}
		if (w2.y2 !== w1.y) {
			return {
				world1: { x: w1.x + 10, y: w1.y, ancho: w1.ancho, alto: w1.alto },
				world2: {
					x1: w1.x,
					y1: w1.y,
					x2: w2.x2 + 10,
					y2: w2.y2 + 25,
					x3: w2.x3 + 10,
					y3: w2.y3 - 25
				},
				world3: w3
			};
		} else {
			return {
				world1: { x: w1.x + 10, y: w1.y, ancho: w1.ancho, alto: w1.alto },
				world2: {
					x1: w1.x,
					y1: w1.y,
					x2: w2.x2 + 10,
					y2: w2.y2 - 50,
					x3: w2.x3 + 10,
					y3: w2.y3 + 50
				},
				world3: w3
			};
		}
	};

	//Implemente esta función si quiere que su programa reaccione a eventos del mouse
	processing.onMouseEvent = function(world, event) {
		// Por ahora no cambia el mundo. Solo retorna una copia del mundo actual
		return make(world, {});
	};

	//Implemente esta función si quiere que su programa reaccione a eventos del teclado
	processing.onKeyEvent = function(world, event) {
		// Por ahora no cambia el mundo. Solo retorna una copia del mundo actual
		return make(world, {});
	};

	// ******************** De aquí hacia abajo no debe cambiar nada. ********************

	// Esta es la función que pinta todo. Se ejecuta 60 veces por segundo.
	// No cambie esta función. Su código debe ir en drawGame
	processing.draw = function() {
		processing.drawGame(processing.state);
		processing.state = processing.onTic(processing.state);
	};

	// Esta función se ejecuta cada vez que presionamos una tecla.
	// No cambie esta función. Su código debe ir en onKeyEvent
	processing.keyPressed = function() {
		processing.state = processing.onKeyEvent(
			processing.state,
			processing.keyCode
		);
	};

	// Esta función se ejecuta cada vez movemos el mouse.
	// No cambie esta función. Su código debe ir en onKeyEvent
	processing.mouseMoved = function() {
		processing.state = processing.onMouseEvent(processing.state, {
			action: 'move',
			mouseX: processing.mouseX,
			mouseY: processing.mouseY
		});
	};

	// Estas funciones controlan los eventos del mouse.
	// No cambie estas funciones. Su código debe ir en OnMouseEvent
	processing.mouseClicked = function() {
		processing.state = processing.onMouseEvent(processing.state, {
			action: 'click',
			mouseX: processing.mouseX,
			mouseY: processing.mouseY,
			mouseButton: processing.mouseButton
		});
	};

	processing.mouseDragged = function() {
		processing.state = processing.onMouseEvent(processing.state, {
			action: 'drag',
			mouseX: processing.mouseX,
			mouseY: processing.mouseY,
			mouseButton: processing.mouseButton
		});
	};

	processing.mousePressed = function() {
		processing.state = processing.onMouseEvent(processing.state, {
			action: 'press',
			mouseX: processing.mouseX,
			mouseY: processing.mouseY,
			mouseButton: processing.mouseButton
		});
	};

	processing.mouseReleased = function() {
		processing.state = processing.onMouseEvent(processing.state, {
			action: 'release',
			mouseX: processing.mouseX,
			mouseY: processing.mouseY,
			mouseButton: processing.mouseButton
		});
	};
	// Fin de los eventos del mouse
}

var canvas = document.getElementById('canvas');

// Adjuntamos nuestro sketch al framework de processing
var processingInstance = new Processing(canvas, sketchProc);
</script>